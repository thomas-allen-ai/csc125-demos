<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Logistic Game – CSC 125</title>
    <style>
        * { box-sizing: border-box; }
        body { margin: 0; padding: 0; background: #f8fafc; -webkit-user-select: none; user-select: none; }
        #root { min-height: 100vh; }
    </style>
</head>
<body>
    <div id="root"></div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/react/18.2.0/umd/react.production.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/18.2.0/umd/react-dom.production.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/7.23.5/babel.min.js"></script>
    <script type="text/babel">

const generateDataset = (nTrain = 30, nTest = 20) => {
  const points = [];
  const generatePoint = (classLabel) => {
    const cx = classLabel === 0 ? -1 : 1;
    const cy = classLabel === 0 ? -0.5 : 0.5;
    return { x: cx + (Math.random() - 0.5) * 2.5, y: cy + (Math.random() - 0.5) * 2.5, label: classLabel };
  };
  for (let i = 0; i < nTrain + nTest; i++) points.push(generatePoint(i % 2));
  for (let i = points.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1)); [points[i], points[j]] = [points[j], points[i]]; }
  return { train: points.slice(0, nTrain), test: points.slice(nTrain) };
};

const sigmoid = (z) => 1 / (1 + Math.exp(-z));
const predictProb = (x, y, w1, w2, b) => sigmoid(w1 * x + w2 * y + b);
const pointLoss = (x, y, label, w1, w2, b) => { const p = Math.max(1e-7, Math.min(1 - 1e-7, predictProb(x, y, w1, w2, b))); return label === 1 ? -Math.log(p) : -Math.log(1 - p); };
const probCorrect = (x, y, label, w1, w2, b) => { const p = predictProb(x, y, w1, w2, b); return label === 1 ? p : 1 - p; };

const computeMetrics = (points, w1, w2, b) => {
  if (points.length === 0) return { loss: 0, accuracy: 0, f1: 0, score: 0 };
  let totalLoss = 0, correct = 0, tp = 0, fp = 0, fn = 0, totalProbCorrect = 0;
  points.forEach(({ x, y, label }) => {
    totalLoss += pointLoss(x, y, label, w1, w2, b);
    const p = predictProb(x, y, w1, w2, b);
    const pred = p >= 0.5 ? 1 : 0;
    if (pred === label) correct++;
    if (pred === 1 && label === 1) tp++;
    if (pred === 1 && label === 0) fp++;
    if (pred === 0 && label === 1) fn++;
    totalProbCorrect += probCorrect(x, y, label, w1, w2, b);
  });
  const precision = tp + fp > 0 ? tp / (tp + fp) : 0;
  const recall = tp + fn > 0 ? tp / (tp + fn) : 0;
  return { loss: totalLoss / points.length, accuracy: correct / points.length, f1: precision + recall > 0 ? 2 * precision * recall / (precision + recall) : 0, score: Math.round(totalProbCorrect * 100) };
};

// SLIDER DEFINED OUTSIDE - not inside LogisticGame
function TouchSlider({ value, onChange, min, max, step, disabled, label, displayValue }) {
  const trackRef = React.useRef(null);
  const [isDragging, setIsDragging] = React.useState(false);
  const valueToPercent = (val) => ((val - min) / (max - min)) * 100;
  const percentToValue = (pct) => min + (pct / 100) * (max - min);
  
  const handleInteraction = React.useCallback((clientX) => {
    if (disabled || !trackRef.current) return;
    const rect = trackRef.current.getBoundingClientRect();
    const pct = Math.max(0, Math.min(100, ((clientX - rect.left) / rect.width) * 100));
    let newVal = percentToValue(pct);
    newVal = Math.round(newVal / step) * step;
    newVal = Math.max(min, Math.min(max, newVal));
    onChange(newVal);
  }, [disabled, min, max, step, onChange]);
  
  const handleThumbTouchStart = (e) => { if (disabled) return; e.preventDefault(); e.stopPropagation(); setIsDragging(true); };
  const handleThumbMouseDown = (e) => { if (disabled) return; e.preventDefault(); e.stopPropagation(); setIsDragging(true); };
  const handleTouchMove = React.useCallback((e) => { if (!isDragging) return; e.preventDefault(); handleInteraction(e.touches[0].clientX); }, [isDragging, handleInteraction]);
  const handleTouchEnd = () => { setIsDragging(false); };
  const handleMouseMove = React.useCallback((e) => { if (!isDragging) return; handleInteraction(e.clientX); }, [isDragging, handleInteraction]);
  const handleMouseUp = () => { setIsDragging(false); };
  
  React.useEffect(() => {
    if (isDragging) {
      const onMouseMove = (e) => handleMouseMove(e);
      const onTouchMove = (e) => handleTouchMove(e);
      window.addEventListener('mousemove', onMouseMove);
      window.addEventListener('mouseup', handleMouseUp);
      window.addEventListener('touchmove', onTouchMove, { passive: false });
      window.addEventListener('touchend', handleTouchEnd);
      return () => { window.removeEventListener('mousemove', onMouseMove); window.removeEventListener('mouseup', handleMouseUp); window.removeEventListener('touchmove', onTouchMove); window.removeEventListener('touchend', handleTouchEnd); };
    }
  }, [isDragging, handleMouseMove, handleTouchMove]);
  
  const percent = valueToPercent(value);
  return (
    <div style={{ marginBottom: '4px', opacity: disabled ? 0.5 : 1 }}>
      <div style={{ display: 'flex', justifyContent: 'space-between', fontSize: '12px', marginBottom: '4px' }}>
        <span style={{ fontWeight: 500 }}>{label}</span>
        <span style={{ color: '#6b7280' }}>{displayValue}</span>
      </div>
      <div ref={trackRef} style={{ position: 'relative', height: '44px', backgroundColor: '#e5e7eb', borderRadius: '22px', cursor: disabled ? 'default' : 'pointer', touchAction: 'none', userSelect: 'none' }}>
        <div style={{ position: 'absolute', left: 0, top: 0, bottom: 0, width: `${percent}%`, backgroundColor: disabled ? '#9ca3af' : '#3b82f6', borderRadius: '22px', pointerEvents: 'none' }} />
        <div onMouseDown={handleThumbMouseDown} onTouchStart={handleThumbTouchStart} style={{ position: 'absolute', left: `${percent}%`, top: '50%', transform: 'translate(-50%, -50%)', width: '60px', height: '60px', cursor: disabled ? 'default' : 'grab', zIndex: 2 }} />
        <div style={{ position: 'absolute', left: `${percent}%`, top: '50%', transform: 'translate(-50%, -50%)', width: '36px', height: '36px', backgroundColor: 'white', borderRadius: '50%', boxShadow: '0 2px 6px rgba(0,0,0,0.3)', pointerEvents: 'none' }} />
      </div>
    </div>
  );
}

const probToColor = (p) => { if (p <= 0.5) { const t = p / 0.5; return `rgb(220,${Math.round(38 + t * 217)},${Math.round(38 + t * 217)})`; } else { const t = (p - 0.5) / 0.5; return `rgb(${Math.round(255 - t * 218)},${Math.round(255 - t * 156)},${Math.round(255 - t * 20)})`; } };
const formatCoef = (coef, isFirst = false) => { const absVal = Math.abs(coef).toFixed(2); return isFirst ? (coef >= 0 ? absVal : `−${absVal}`) : (coef >= 0 ? ` + ${absVal}` : ` − ${absVal}`); };

function LogisticGame() {
  const [round, setRound] = React.useState(1);
  const [totalScore, setTotalScore] = React.useState(0);
  const [phase, setPhase] = React.useState('playing');
  const [dataset, setDataset] = React.useState(() => generateDataset());
  const [visibleTrainCount, setVisibleTrainCount] = React.useState(1);
  const [roundScoreAdded, setRoundScoreAdded] = React.useState(false);
  const [angle, setAngle] = React.useState(() => Math.random() * 360);
  const [sharpness, setSharpness] = React.useState(() => 0.5 + Math.random() * 1);
  const [slide, setSlide] = React.useState(() => (Math.random() - 0.5) * 2);
  const [isLandscape, setIsLandscape] = React.useState(() => window.innerWidth > window.innerHeight);
  
  React.useEffect(() => { const h = () => setIsLandscape(window.innerWidth > window.innerHeight); window.addEventListener('resize', h); return () => window.removeEventListener('resize', h); }, []);
  
  const angleRad = (angle * Math.PI) / 180;
  const w1 = sharpness * Math.cos(angleRad), w2 = sharpness * Math.sin(angleRad), b = -slide * sharpness;
  const visibleTrain = dataset.train.slice(0, visibleTrainCount);
  const trainMetrics = computeMetrics(visibleTrain, w1, w2, b);
  const testMetrics = phase === 'revealed' ? computeMetrics(dataset.test, w1, w2, b) : null;
  
  React.useEffect(() => { if (phase !== 'playing') return; if (visibleTrainCount >= dataset.train.length) { const t = setTimeout(() => setPhase('revealed'), 1500); return () => clearTimeout(t); } const t = setTimeout(() => setVisibleTrainCount(c => c + 1), 800); return () => clearTimeout(t); }, [visibleTrainCount, phase, dataset.train.length]);
  React.useEffect(() => { if (phase === 'revealed' && testMetrics && !roundScoreAdded) { setTotalScore(prev => prev + testMetrics.score); setRoundScoreAdded(true); } }, [phase, testMetrics, roundScoreAdded]);
  
  const nextRound = () => { setDataset(generateDataset()); setVisibleTrainCount(1); setAngle(Math.random() * 360); setSharpness(0.5 + Math.random() * 1); setSlide((Math.random() - 0.5) * 2); setRound(r => r + 1); setPhase('playing'); setRoundScoreAdded(false); };

  const xRange = [-3, 3], yRange = [-3, 3];
  const toSvgX = (x) => ((x - xRange[0]) / 6) * 400, toSvgY = (y) => ((yRange[1] - y) / 6) * 400;
  const wNorm = Math.sqrt(w1 * w1 + w2 * w2), dirX = wNorm > 0.001 ? w1 / wNorm : 1, dirY = wNorm > 0.001 ? w2 / wNorm : 0;
  const logit = (p) => Math.log(p / (1 - p));
  const gradX1Pct = ((-dirX * 8 + 3) / 6) * 100, gradY1Pct = ((3 + dirY * 8) / 6) * 100, gradX2Pct = ((dirX * 8 + 3) / 6) * 100, gradY2Pct = ((3 - dirY * 8) / 6) * 100;
  const bandProbs = [0.02, 0.10, 0.25, 0.40, 0.50, 0.60, 0.75, 0.90, 0.98];
  const gradientStops = bandProbs.map(p => ({ offset: Math.max(0, Math.min(100, 50 + ((slide + logit(p) / sharpness) / 8) * 50)), color: probToColor(p) })).sort((a, b) => a.offset - b.offset);
  const finalStops = []; if (gradientStops[0].offset > 0) finalStops.push({ offset: 0, color: gradientStops[0].color }); gradientStops.forEach(s => finalStops.push(s)); if (finalStops[finalStops.length - 1].offset < 100) finalStops.push({ offset: 100, color: finalStops[finalStops.length - 1].color });
  const arrowBaseX = slide * dirX, arrowBaseY = slide * dirY, arrowTipX = arrowBaseX + dirX * 1.2, arrowTipY = arrowBaseY + dirY * 1.2;
  const arrowHead1X = arrowTipX - 0.3 * Math.cos(angleRad - Math.PI/6), arrowHead1Y = arrowTipY - 0.3 * Math.sin(angleRad - Math.PI/6);
  const arrowHead2X = arrowTipX - 0.3 * Math.cos(angleRad + Math.PI/6), arrowHead2Y = arrowTipY - 0.3 * Math.sin(angleRad + Math.PI/6);
  const sliderLocked = phase === 'revealed', gradientId = `g-${round}-${angle}`;

  // SCORE HEADER JSX
  const scoreHeader = (
    <div style={{ textAlign: 'center', padding: '8px', backgroundColor: '#1e293b', borderRadius: '10px', color: 'white', marginBottom: '6px' }}>
      <div style={{ fontSize: '26px', fontWeight: 'bold' }}>{totalScore.toLocaleString()}</div>
      <div style={{ fontSize: '12px', opacity: 0.8 }}>Round {round} {phase === 'playing' ? '• Training...' : '• Test Revealed!'}</div>
    </div>
  );
  
  // PLOT JSX
  const plot = (
    <div style={{ backgroundColor: 'white', borderRadius: '10px', overflow: 'hidden', boxShadow: '0 2px 8px rgba(0,0,0,0.1)' }}>
      <svg width="100%" viewBox="0 0 400 400" style={{ display: 'block' }}>
        <defs><linearGradient id={gradientId} x1={`${gradX1Pct}%`} y1={`${gradY1Pct}%`} x2={`${gradX2Pct}%`} y2={`${gradY2Pct}%`}>{finalStops.map((s, i) => <stop key={i} offset={`${s.offset}%`} stopColor={s.color} />)}</linearGradient></defs>
        <rect width="400" height="400" fill={`url(#${gradientId})`} />
        {[-2,-1,0,1,2].map(v => <g key={v}><line x1={toSvgX(v)} y1={0} x2={toSvgX(v)} y2={400} stroke="rgba(255,255,255,0.4)" /><line x1={0} y1={toSvgY(v)} x2={400} y2={toSvgY(v)} stroke="rgba(255,255,255,0.4)" /></g>)}
        <line x1={toSvgX(arrowBaseX)} y1={toSvgY(arrowBaseY)} x2={toSvgX(arrowTipX)} y2={toSvgY(arrowTipY)} stroke="#1d4ed8" strokeWidth="3" strokeLinecap="round" />
        <polygon points={`${toSvgX(arrowTipX)},${toSvgY(arrowTipY)} ${toSvgX(arrowHead1X)},${toSvgY(arrowHead1Y)} ${toSvgX(arrowHead2X)},${toSvgY(arrowHead2Y)}`} fill="#1d4ed8" />
        {visibleTrain.map((pt, i) => <circle key={i} cx={toSvgX(pt.x)} cy={toSvgY(pt.y)} r={10} fill={pt.label === 0 ? '#dc2626' : '#2563eb'} stroke="white" strokeWidth="2" />)}
        {phase === 'revealed' && dataset.test.map((pt, i) => <circle key={i} cx={toSvgX(pt.x)} cy={toSvgY(pt.y)} r={10} fill={pt.label === 0 ? '#dc2626' : '#2563eb'} stroke="#fbbf24" strokeWidth="3" />)}
      </svg>
      <div style={{ textAlign: 'center', padding: '8px 4px', fontSize: '15px', fontFamily: 'Georgia, serif', color: '#374151', borderTop: '1px solid #e5e7eb' }}><span style={{ fontStyle: 'italic' }}>{formatCoef(w1, true)}x₁{formatCoef(w2)}x₂{formatCoef(b)}</span><span style={{ margin: '0 8px', color: '#6b7280' }}>→</span><span style={{ color: '#2563eb', fontWeight: 500 }}>P(blue)</span></div>
      <div style={{ display: 'flex', justifyContent: 'center', gap: '16px', fontSize: '11px', color: '#6b7280', paddingBottom: '6px' }}><span><span style={{ color: '#dc2626' }}>●</span> Class 0</span><span><span style={{ color: '#2563eb' }}>●</span> Class 1</span>{phase === 'revealed' && <span><span style={{ color: '#fbbf24' }}>◯</span> Test</span>}</div>
    </div>
  );

  // SLIDERS JSX
  const sliders = (
    <div style={{ backgroundColor: 'white', borderRadius: '10px', padding: '10px 12px', marginBottom: '6px', boxShadow: '0 2px 8px rgba(0,0,0,0.1)' }}>
      <TouchSlider label="Angle" value={angle} onChange={setAngle} min={0} max={360} step={1} disabled={sliderLocked} displayValue={`${Math.round(angle)}°`} />
      <TouchSlider label="Sharpness" value={sharpness} onChange={setSharpness} min={0.1} max={3} step={0.05} disabled={sliderLocked} displayValue={sharpness.toFixed(2)} />
      <TouchSlider label="Slide" value={slide} onChange={setSlide} min={-3} max={3} step={0.1} disabled={sliderLocked} displayValue={slide.toFixed(1)} />
    </div>
  );

  // METRICS JSX
  const metrics = (
    <div style={{ backgroundColor: 'white', borderRadius: '10px', padding: '10px', marginBottom: '6px', boxShadow: '0 2px 8px rgba(0,0,0,0.1)' }}>
      <div style={{ display: 'grid', gridTemplateColumns: '1fr 1fr 1fr', gap: '8px', textAlign: 'center' }}>
        <div><div style={{ fontSize: '10px', color: '#6b7280', marginBottom: '2px' }}>Loss</div><div style={{ fontSize: '16px', fontWeight: '600' }}>{trainMetrics.loss.toFixed(2)}</div></div>
        <div><div style={{ fontSize: '10px', color: '#6b7280', marginBottom: '2px' }}>Accuracy</div><div style={{ fontSize: '16px', fontWeight: '600' }}>{(trainMetrics.accuracy * 100).toFixed(0)}%</div></div>
        <div><div style={{ fontSize: '10px', color: '#6b7280', marginBottom: '2px' }}>F1</div><div style={{ fontSize: '16px', fontWeight: '600' }}>{trainMetrics.f1.toFixed(2)}</div></div>
      </div>
      {phase === 'revealed' && testMetrics && (<><hr style={{ margin: '10px 0', border: 'none', borderTop: '1px solid #e5e7eb' }} /><div style={{ fontSize: '11px', color: '#059669', textAlign: 'center', marginBottom: '6px', fontWeight: 500 }}>Test Results</div>
        <div style={{ display: 'grid', gridTemplateColumns: '1fr 1fr 1fr', gap: '8px', textAlign: 'center' }}>
          <div><div style={{ fontSize: '10px', color: '#6b7280', marginBottom: '2px' }}>Loss</div><div style={{ fontSize: '16px', fontWeight: '600', color: '#059669' }}>{testMetrics.loss.toFixed(2)}</div></div>
          <div><div style={{ fontSize: '10px', color: '#6b7280', marginBottom: '2px' }}>Accuracy</div><div style={{ fontSize: '16px', fontWeight: '600', color: '#059669' }}>{(testMetrics.accuracy * 100).toFixed(0)}%</div></div>
          <div><div style={{ fontSize: '10px', color: '#6b7280', marginBottom: '2px' }}>Points</div><div style={{ fontSize: '16px', fontWeight: '600', color: '#059669' }}>+{testMetrics.score}</div></div>
        </div></>)}
    </div>
  );

  // BOTTOM JSX
  const bottom = phase === 'revealed' 
    ? <button onClick={nextRound} style={{ width: '100%', padding: '14px', fontSize: '16px', fontWeight: '600', backgroundColor: '#2563eb', color: 'white', border: 'none', borderRadius: '10px', cursor: 'pointer' }}>Next Round →</button>
    : <div style={{ textAlign: 'center', color: '#6b7280', fontSize: '12px', padding: '6px', backgroundColor: 'white', borderRadius: '10px' }}>Training: {visibleTrainCount} / {dataset.train.length}</div>;

  // LANDSCAPE LAYOUT
  if (isLandscape) {
    return (
      <div style={{ fontFamily: '-apple-system, BlinkMacSystemFont, sans-serif', display: 'flex', alignItems: 'flex-start', justifyContent: 'center', padding: '10px', gap: '16px', backgroundColor: '#f8fafc', minHeight: '100vh' }}>
        <div style={{ height: 'calc(100vh - 20px)', aspectRatio: '1', maxWidth: '55vw' }}>{plot}</div>
        <div style={{ width: '300px' }}>{scoreHeader}{sliders}{metrics}{bottom}</div>
      </div>
    );
  }

  // PORTRAIT LAYOUT
  return (
    <div style={{ fontFamily: '-apple-system, BlinkMacSystemFont, sans-serif', padding: '4px', backgroundColor: '#f8fafc', minHeight: '100vh' }}>
      {scoreHeader}
      <div style={{ marginBottom: '6px' }}>{plot}</div>
      {sliders}
      {metrics}
      {bottom}
    </div>
  );
}

ReactDOM.createRoot(document.getElementById('root')).render(<LogisticGame />);
    </script>
</body>
</html>
